//! Prompt file generation for agent execution.
//!
//! This module generates prompt files that provide context to agents
//! when executing tasks.

use super::context::TaskContext;
use super::template::{TemplateError, render_template};
use crate::agent::config::{AgentProfile, AgentsConfig, default_prompt_template_content};
use crate::context::WorkflowContext;
use crate::error::{BurlError, Result};
use crate::fs::atomic_write_file;
use crate::task::TaskFile;
use chrono::Utc;
use std::collections::HashMap;
use std::path::PathBuf;

/// Result of generating a prompt file.
#[derive(Debug, Clone)]
pub struct GeneratedPrompt {
    /// Path to the generated prompt file.
    pub path: PathBuf,
    /// The generated prompt content.
    pub content: String,
}

/// Generate a prompt file for a task.
///
/// # Arguments
///
/// * `ctx` - The workflow context
/// * `task` - The task file to generate a prompt for
/// * `agent` - The agent profile (for selecting prompt template)
/// * `agents_config` - The agents configuration (contains prompt templates)
///
/// # Returns
///
/// The path to the generated prompt file and its content.
pub fn generate_prompt(
    ctx: &WorkflowContext,
    task: &TaskFile,
    agent: &AgentProfile,
    agents_config: &AgentsConfig,
) -> Result<GeneratedPrompt> {
    // Extract task context
    let task_ctx = TaskContext::from_task(task);

    // Get prompt template
    let template_name = agent.effective_prompt_template(&agents_config.defaults);
    let template = agents_config
        .get_prompt_template(template_name)
        .unwrap_or_else(|| default_prompt_template_content());

    // Build template variables
    let mut vars = task_ctx.to_template_vars();

    // Add runtime paths
    let prompt_path = ctx.prompt_file_path(&task.frontmatter.id);
    let task_file_path = find_task_file_path(ctx, &task.frontmatter.id);

    if let Some(ref path) = task_file_path {
        vars.insert("task_file".to_string(), path.clone());
    }
    vars.insert(
        "prompt_file".to_string(),
        prompt_path.to_string_lossy().to_string(),
    );

    // Render the template
    let rendered = render_template(template, &vars).map_err(|e| match e {
        TemplateError::UndefinedVariable { name, .. } => BurlError::UserError(format!(
            "prompt template references undefined variable '{}'\n\
             Available variables: {}",
            name,
            available_vars(&vars)
        )),
        TemplateError::UnmatchedBrace { position } => BurlError::UserError(format!(
            "prompt template has unmatched '{{' at position {}",
            position
        )),
        TemplateError::EmptyVariableName { position } => BurlError::UserError(format!(
            "prompt template has empty variable name at position {}",
            position
        )),
    })?;

    // Add metadata header
    let content = format_prompt_with_header(&task.frontmatter.id, agent, &rendered);

    Ok(GeneratedPrompt {
        path: prompt_path,
        content,
    })
}

/// Write a generated prompt to disk.
///
/// Creates the prompts directory if it doesn't exist and writes the
/// prompt file atomically.
pub fn write_prompt(ctx: &WorkflowContext, prompt: &GeneratedPrompt) -> Result<()> {
    // Ensure prompts directory exists
    let prompts_dir = ctx.prompts_dir();
    if !prompts_dir.exists() {
        std::fs::create_dir_all(&prompts_dir).map_err(|e| {
            BurlError::UserError(format!(
                "failed to create prompts directory '{}': {}",
                prompts_dir.display(),
                e
            ))
        })?;
    }

    // Write atomically
    atomic_write_file(&prompt.path, &prompt.content)?;

    Ok(())
}

/// Generate and write a prompt file in one operation.
pub fn generate_and_write_prompt(
    ctx: &WorkflowContext,
    task: &TaskFile,
    agent: &AgentProfile,
    agents_config: &AgentsConfig,
) -> Result<GeneratedPrompt> {
    let prompt = generate_prompt(ctx, task, agent, agents_config)?;
    write_prompt(ctx, &prompt)?;
    Ok(prompt)
}

/// Format the prompt with a metadata header.
fn format_prompt_with_header(task_id: &str, agent: &AgentProfile, body: &str) -> String {
    let timestamp = Utc::now().format("%Y-%m-%dT%H:%M:%SZ");
    let agent_name = if agent.name.is_empty() {
        "unknown"
    } else {
        &agent.name
    };

    format!(
        "<!-- Prompt generated by burl -->\n\
         <!-- Task: {} -->\n\
         <!-- Agent: {} -->\n\
         <!-- Generated: {} -->\n\n\
         {}",
        task_id, agent_name, timestamp, body
    )
}

/// Find the path to a task file in workflow buckets.
///
/// Returns the absolute path if found, None otherwise.
fn find_task_file_path(ctx: &WorkflowContext, task_id: &str) -> Option<String> {
    // Check DOING bucket first (most likely for agent execution)
    for bucket in ["DOING", "READY", "QA", "DONE", "BLOCKED"] {
        let bucket_dir = ctx.bucket_path(bucket);
        if let Ok(entries) = std::fs::read_dir(&bucket_dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.is_file()
                    && let Some(name) = path.file_name().and_then(|n| n.to_str())
                    && name.starts_with(task_id)
                    && name.ends_with(".md")
                {
                    return Some(path.to_string_lossy().to_string());
                }
            }
        }
    }
    None
}

/// Get a formatted list of available variables for error messages.
fn available_vars(vars: &HashMap<String, String>) -> String {
    let mut keys: Vec<_> = vars.keys().collect();
    keys.sort();
    keys.iter()
        .map(|k| k.as_str())
        .collect::<Vec<_>>()
        .join(", ")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::agent::config::AgentDefaults;
    use crate::task::TaskFrontmatter;
    use std::collections::BTreeMap;
    use tempfile::TempDir;

    fn make_test_task() -> TaskFile {
        TaskFile {
            frontmatter: TaskFrontmatter {
                id: "TASK-001".to_string(),
                title: "Test Task".to_string(),
                priority: "high".to_string(),
                affects: vec!["src/main.rs".to_string()],
                affects_globs: vec!["src/**/*.rs".to_string()],
                must_not_touch: vec!["config.yaml".to_string()],
                worktree: Some("/path/to/worktree".to_string()),
                branch: Some("task-001".to_string()),
                base_sha: Some("abc123".to_string()),
                ..Default::default()
            },
            body: r#"
## Objective
Implement the feature.

## Acceptance Criteria
- Tests pass
- No regressions
"#
            .to_string(),
        }
    }

    fn make_test_agent() -> AgentProfile {
        AgentProfile {
            name: "Test Agent".to_string(),
            command: "echo test".to_string(),
            ..Default::default()
        }
    }

    fn make_test_agents_config() -> AgentsConfig {
        let mut templates = BTreeMap::new();
        templates.insert(
            "default".to_string(),
            "# Task: {title}\n\n{objective}\n\nAffects: {affects}".to_string(),
        );

        AgentsConfig {
            agents: BTreeMap::new(),
            defaults: AgentDefaults::default(),
            prompt_templates: templates,
            extra: BTreeMap::new(),
        }
    }

    #[test]
    fn test_generate_prompt_basic() {
        let temp_dir = TempDir::new().unwrap();
        let ctx = make_test_context(&temp_dir);
        let task = make_test_task();
        let agent = make_test_agent();
        let config = make_test_agents_config();

        let result = generate_prompt(&ctx, &task, &agent, &config);
        assert!(result.is_ok());

        let prompt = result.unwrap();
        assert!(prompt.content.contains("Task: Test Task"));
        assert!(prompt.content.contains("Implement the feature."));
        assert!(prompt.content.contains("src/main.rs"));
    }

    #[test]
    fn test_generate_prompt_has_header() {
        let temp_dir = TempDir::new().unwrap();
        let ctx = make_test_context(&temp_dir);
        let task = make_test_task();
        let agent = make_test_agent();
        let config = make_test_agents_config();

        let prompt = generate_prompt(&ctx, &task, &agent, &config).unwrap();

        assert!(prompt.content.contains("<!-- Prompt generated by burl -->"));
        assert!(prompt.content.contains("<!-- Task: TASK-001 -->"));
        assert!(prompt.content.contains("<!-- Agent: Test Agent -->"));
        assert!(prompt.content.contains("<!-- Generated:"));
    }

    #[test]
    fn test_generate_prompt_uses_custom_template() {
        let temp_dir = TempDir::new().unwrap();
        let ctx = make_test_context(&temp_dir);
        let task = make_test_task();

        let mut agent = make_test_agent();
        agent.prompt_template = Some("custom".to_string());

        let mut config = make_test_agents_config();
        config
            .prompt_templates
            .insert("custom".to_string(), "CUSTOM: {task_id}".to_string());

        let prompt = generate_prompt(&ctx, &task, &agent, &config).unwrap();

        assert!(prompt.content.contains("CUSTOM: TASK-001"));
    }

    #[test]
    fn test_generate_prompt_fallback_to_default_template() {
        let temp_dir = TempDir::new().unwrap();
        let ctx = make_test_context(&temp_dir);
        let task = make_test_task();
        let agent = make_test_agent();

        // Empty prompt templates - should use hardcoded default
        let config = AgentsConfig::default();

        let result = generate_prompt(&ctx, &task, &agent, &config);
        assert!(result.is_ok());

        let prompt = result.unwrap();
        // Should contain content from default_prompt_template_content()
        assert!(!prompt.content.contains("{title}")); // Variables should be substituted
        assert!(prompt.content.contains("Test Task")); // Title should appear
    }

    #[test]
    fn test_generate_prompt_undefined_variable_error() {
        let temp_dir = TempDir::new().unwrap();
        let ctx = make_test_context(&temp_dir);
        let task = make_test_task();
        let agent = make_test_agent();

        let mut config = make_test_agents_config();
        config.prompt_templates.insert(
            "default".to_string(),
            "Task: {title}\nUndefined: {nonexistent}".to_string(),
        );

        let result = generate_prompt(&ctx, &task, &agent, &config);
        assert!(result.is_err());

        let err = result.unwrap_err().to_string();
        assert!(err.contains("undefined variable 'nonexistent'"));
        assert!(err.contains("Available variables:"));
    }

    #[test]
    fn test_write_prompt_creates_directory() {
        let temp_dir = TempDir::new().unwrap();
        let ctx = make_test_context(&temp_dir);

        let prompt = GeneratedPrompt {
            path: ctx.prompt_file_path("TASK-001"),
            content: "test content".to_string(),
        };

        // Directory shouldn't exist yet
        assert!(!ctx.prompts_dir().exists());

        write_prompt(&ctx, &prompt).unwrap();

        // Directory should now exist
        assert!(ctx.prompts_dir().exists());
        assert!(prompt.path.exists());
    }

    #[test]
    fn test_write_prompt_atomic() {
        let temp_dir = TempDir::new().unwrap();
        let ctx = make_test_context(&temp_dir);
        std::fs::create_dir_all(ctx.prompts_dir()).unwrap();

        let prompt = GeneratedPrompt {
            path: ctx.prompt_file_path("TASK-001"),
            content: "initial content".to_string(),
        };

        write_prompt(&ctx, &prompt).unwrap();

        // Update and write again
        let prompt = GeneratedPrompt {
            path: ctx.prompt_file_path("TASK-001"),
            content: "updated content".to_string(),
        };

        write_prompt(&ctx, &prompt).unwrap();

        let content = std::fs::read_to_string(&prompt.path).unwrap();
        assert_eq!(content, "updated content");
    }

    #[test]
    fn test_format_prompt_with_header() {
        let agent = make_test_agent();
        let body = "Test body content";

        let result = format_prompt_with_header("TASK-001", &agent, body);

        assert!(result.starts_with("<!-- Prompt generated by burl -->"));
        assert!(result.contains("<!-- Task: TASK-001 -->"));
        assert!(result.contains("<!-- Agent: Test Agent -->"));
        assert!(result.contains("<!-- Generated: "));
        assert!(result.ends_with("Test body content"));
    }

    // Helper to create a test WorkflowContext
    fn make_test_context(temp_dir: &TempDir) -> WorkflowContext {
        let repo_root = temp_dir.path().to_path_buf();
        let workflow_worktree = repo_root.join(".burl");
        let workflow_state_dir = workflow_worktree.join(".workflow");
        let locks_dir = workflow_state_dir.join("locks");
        let worktrees_dir = repo_root.join(".worktrees");

        WorkflowContext {
            repo_root,
            workflow_worktree,
            workflow_state_dir,
            locks_dir,
            worktrees_dir,
        }
    }
}
